<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="关于JVM（基于hotspot）JVM整体结构   JVM的架构模型 基于栈式架构  JVM生命周期启动——执行——退出   JVM内存区域类加载子系统类加载器和类的加载过程      类的加载过程 一个Java文件从编码完成到最终运行，一般会经历两个阶段：编译期、运行期。编译，即通过javac命令，将Java文件转化为二进制字节码文件，即.class文件；运行，则是将.class文件交给JVM执">
<meta property="og:type" content="article">
<meta property="og:title" content="The-first-blog">
<meta property="og:url" content="http://example.com/2022/10/16/The-first-blog/index.html">
<meta property="og:site_name" content="Perserverance">
<meta property="og:description" content="关于JVM（基于hotspot）JVM整体结构   JVM的架构模型 基于栈式架构  JVM生命周期启动——执行——退出   JVM内存区域类加载子系统类加载器和类的加载过程      类的加载过程 一个Java文件从编码完成到最终运行，一般会经历两个阶段：编译期、运行期。编译，即通过javac命令，将Java文件转化为二进制字节码文件，即.class文件；运行，则是将.class文件交给JVM执">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927101506965.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920094922812.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920101026112.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920102914097.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920102933595.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920103222871.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920103234998.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920104243326.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920104757585.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920104740671.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920110604499.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920110910892.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920110924167.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920111431881.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920112538821.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920160057893.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920160256311.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927090611262.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927090624171.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920130631247.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920130824249.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920131249704.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920132635850.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920134602495.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920144548977.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920134602495.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920154750258.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920152230945.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920151406561.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920140502286.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920152641999.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220920153320008.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922102407895.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922103004735.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922103042499.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922103933396.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922104555434.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922104700100.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922114918122.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922112757011.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922114457556.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922103004735.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922115103658.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922115138514.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922115320841.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922115459403.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922121032602.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922121325647.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922121415970.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922120356973.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922120446022.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922120737732.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922121753369.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922121856779.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922122019231.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922122228725.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922122243126.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922153214796.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922133628454.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922140150860.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922140309136.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144053348.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922141344440.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922141157285.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144036851.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144108124.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144120973.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144135710.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144310733.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144332069.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922145200405.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144804451.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922145236412.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922144828044.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922153608081.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922150755930.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922150447171.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922150457435.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922150557178.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922150921447.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922151651694.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922151601001.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922151610177.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922151618655.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922151630355.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220922152641277.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924115541013.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924115552912.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924130607798.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924130732990.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924130747487.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927090842602.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924130821628.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924130804702.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924130858208.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924131136904.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924131144565.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924131227943.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924131239943.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924141814214.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924141918126.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220924142141419.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927101930526.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927101843595.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927102014262.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927101916109.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927101941987.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927101954168.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927102003408.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927103311050.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927102743735.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927105415037.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927105528630.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927105607060.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927110813485.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927111435033.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927113802658.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927114247641.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927114457272.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927134856686.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927121647339.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927124003012.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927141828861.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927141855732.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927142308928.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927154321104.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927153736307.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927153800393.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927151535365.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927155518020.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927164118327.png">
<meta property="og:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927164103083.png">
<meta property="article:published_time" content="2022-10-16T05:45:39.000Z">
<meta property="article:modified_time" content="2022-10-16T05:48:32.033Z">
<meta property="article:author" content="EddieZhang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/ZJH20/AppData/Roaming/Typora/typora-user-images/image-20220927101506965.png">

<link rel="canonical" href="http://example.com/2022/10/16/The-first-blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>The-first-blog | Perserverance</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Perserverance</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description"> </p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/16/The-first-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="EddieZhang">
      <meta itemprop="description" content="当你开始认真的时候，全世界都会给你让路！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Perserverance">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          The-first-blog
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-16 13:45:39 / 修改时间：13:48:32" itemprop="dateCreated datePublished" datetime="2022-10-16T13:45:39+08:00">2022-10-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="关于JVM（基于hotspot）"><a href="#关于JVM（基于hotspot）" class="headerlink" title="关于JVM（基于hotspot）"></a>关于JVM（基于hotspot）</h1><h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927101506965.png" alt="image-20220927101506965"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920094922812.png" alt="image-20220920094922812"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920101026112.png" alt="image-20220920101026112"></p>
<h2 id="JVM的架构模型-基于栈式架构"><a href="#JVM的架构模型-基于栈式架构" class="headerlink" title="JVM的架构模型 基于栈式架构"></a><strong>JVM的架构模型 基于栈式架构</strong></h2><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920102914097.png" alt="image-20220920102914097"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920102933595.png" alt="image-20220920102933595"></p>
<h2 id="JVM生命周期"><a href="#JVM生命周期" class="headerlink" title="JVM生命周期"></a>JVM生命周期</h2><p><strong>启动——执行——退出</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920103222871.png" alt="image-20220920103222871"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920103234998.png" alt="image-20220920103234998"></p>
<h1 id="JVM内存区域"><a href="#JVM内存区域" class="headerlink" title="JVM内存区域"></a>JVM内存区域</h1><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><h3 id="类加载器和类的加载过程"><a href="#类加载器和类的加载过程" class="headerlink" title="类加载器和类的加载过程"></a>类加载器和类的加载过程</h3><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920104243326.png" alt="image-20220920104243326"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920104757585.png" alt="image-20220920104757585"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920104740671.png" alt="image-20220920104740671"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920110604499.png" alt="image-20220920110604499"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920110910892.png" alt="image-20220920110910892"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920110924167.png" alt="image-20220920110924167"></p>
<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920111431881.png" alt="image-20220920111431881"></p>
<p>一个Java文件从编码完成到最终运行，一般会经历两个阶段：编译期、运行期。编译，即通过javac命令，将Java文件转化为二进制字节码文件，即.class文件；运行，则是将.class文件交给JVM执行。而本文所说的类加载过程就是将.class文件中类的元信息加载进内存，创建Class对象并进行解析、初始化类变量等的过程<br>        JVM并不是一开始就会将所有的类加载到内存，而是用到某个类，才会去加载，只加载一次，后续会说到类的加载时机</p>
<ol start="2">
<li>类加载详解<br>类加载分为三个部分：加载、连接、初始化</li>
<li><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920112538821.png" alt="image-20220920112538821"></li>
</ol>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载<br>        <strong>类的加载主要的职责为将.class文件的二进制字节流读入内存</strong>(JDK1.7及之前为JVM内存(方法区)，JDK1.8及之后为本地内存(元空间))，并<strong>在堆内存中为之创建Class对象</strong>，<strong>作为.class进入内存后的数据的访问入口</strong>。</p>
<p><strong>在这里只是读入二进制字节流，后续的验证阶段就是要拿二进制字节流来验证.class文件，验证通过，才会将.class文件转为运行时数据结构</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920160057893.png" alt="image-20220920160057893"></p>
<p>​        <strong>++拓展</strong>： 在<strong>JDK1.7及以前</strong>，Hot Spot JVM(普遍在用的JVM)存在一块叫做<strong>方法区</strong>的内存，也称之为<strong>永久代</strong>，这块区域用于存放类的元数据信息，包括类的字段，版本，方法等，这块区域，可以理解为.class文件进入内存后的位置。在<strong>JDK1.8</strong>，取消了方法区，取而代之的是<strong>元数据区</strong>，该元数据区并非JVM内存，而是<strong>本地内存</strong>。此外在JDK1.7时，将常量池从方法区移除，在堆内存开辟了一块空间作为常量池，有人说这是为取消方法区做的准备。更多请点我看思维导图总结<br>​        <strong>++加分项： 为何取消方法区</strong>？<br>​        官方说法为：<strong>移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力</strong>，<strong>因为JRockit没有永久代</strong>，不需要配置永久代<br>​        现实使用中存在问题：方法区存储类的元数据信息，我们不清楚一个程序到底有多少类需要被加载，且方法区位于JVM内存，我们不清楚需要给方法区分配多大内存，太小容易PermGen OOM，太大，在触发Full GC时又极其影响性能，同时还存在一些内存泄露的问题</p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>该阶段主要是为了<strong>保证加载进来的字节流符合JVM的规范</strong>，<strong>不会对JVM有安全性问题</strong>。其中有对元数据的验证，例如检查类是否继承了被final修饰的类；还有对符号引用的验证，例如校验符号引用是否可以通过全限定名找到，或者是检查符号引用的权限(private、public)是否符合语法规定等。</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920160256311.png" alt="image-20220920160256311"></p>
<p>主要包括四种验证：<strong>文件格式验证</strong> <strong>元数据验证</strong> <strong>字节码验证</strong> <strong>符号引用验证</strong></p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备阶段的主要任务是<strong>为类的类变量（static）开辟空间并赋默认值</strong>。</p>
<p>1、静态变量是基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0<br>2、静态变量是引用类型的，默认值为null<br>3、静态常量默认值为声明时设定的值</p>
<p><strong>例如：public static final int i &#x3D; 3; 在准备阶段，i的值即为3</strong></p>
<p><strong>static final 在编译的时候就分配 准备阶段会显示初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">3</span>;<span class="comment">//prepare:num = 3;//static final在准备阶段就显示初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//prepare:num = 0;initial:num = 1;准备阶段的主要任务是**为类的类变量（static）开辟空间并赋默认值**</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里不会为实例变量分配初始化，</strong> <strong>类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆中</strong></p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>该阶段的主要职责为将Class在常量池中的符号引用转变为直接引用</strong>，</p>
<p>此处针对的是<strong>静态方法及属性和私有方法与属性</strong>，<strong>因为这类方法与私有方法不能被重写</strong>，静态属性在运行期也没有多态这一说，即<strong>在编译器可知，运行期不可变，所以适合在该阶段解析</strong>，譬如类方法main替换为直接引用，为静态连接，区别于运行时的动态连接(后续我会写关于JVM内存结构的文章，在讲解栈帧时会介绍动态链接)。<br><strong>符号引用即字符串，说白了可以是一个字段名，或者一个方法名</strong>；<strong>直接引用即偏移量</strong>，<strong>说白了就是类的元信息位于内存的地址串</strong>，例如，一个类的方法为test()，则符号引用即为test，这个方法存在于内存中的地址假设为0x123456，则这个地址则为直接引用</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927090611262.png" alt="image-20220927090611262"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927090624171.png" alt="image-20220927090624171"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类的<strong>初始化顺序</strong>：先执行父类静态变量赋值、父类静态初始化块，再执行子类静态属性赋值、静态初始化块</p>
<p><strong>执行类的构造器方法（clinit（））的过程</strong></p>
<p><strong>此方法不需要定义 是javac编译器自动收集类中的所有 类变量（static）的赋值动作和静态代码块中的语句合并而来</strong></p>
<p><strong>clinit（）构造器方法中的指令语句是按照源文件中出现的顺序</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920130631247.png" alt="image-20220920130631247"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920130824249.png" alt="image-20220920130824249"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">//静态代码块</span></span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(num);<span class="comment">//2</span></span><br><span class="line">        System.out.println(number);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>clinit()方法是javac编译器自动收集类中的所有 类变量（static）的赋值动作和静态代码块中的语句合并而来</strong></p>
<p><strong>如果没有类变量（static）的赋值动作和静态代码块</strong> <strong>就不会有clinit()方法</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920131249704.png" alt="image-20220920131249704"></p>
<p><strong>任何一个类生声明后，内部至少存在一个类的构造器</strong></p>
<p>若该类有父类：<strong>JVM保证子类的clinit()方法执行前 父类的clinit()方法已经执行完毕</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920132635850.png" alt="image-20220920132635850"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类先加载 其次加载子类 静态先行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;<span class="comment">//父类先加载</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;<span class="comment">//其次加载子类</span></span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//父类先加载 其次加载子类 静态先行</span></span><br><span class="line">        System.out.println(Son.number);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JVM必须保证一个类的clinit()方法在多线程下被同步加锁</strong></p>
<p><strong>保证clinit()方法只加载一次</strong></p>
<p><strong>clinit()方法</strong> <strong>clinit()方法是javac编译器自动收集类中的所有 类变量（static）的赋值动作和静态代码块中的语句合并而来</strong></p>
<p><strong>如果没有类变量（static）的赋值动作和静态代码块</strong> <strong>就不会有clinit()方法</strong></p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><strong>引导类加载器（Bootstrap ClassLoader）</strong></p>
<p><strong>自定义类加载器（User-Defined ClassLoader）</strong></p>
<p><strong>所有派生于抽象类ClassLoader的类加载器划分为自定义类加载器</strong></p>
<p>了解自定义类加载器：</p>
<p>通过前面的分析可知，<strong>实现自定义类加载器需要继承ClassLoader或者URLClassLoader</strong>，<strong>继承ClassLoader则需要自己重写findClass()方法并编写加载逻辑</strong>，<strong>继承URLClassLoader则可以省去编写findClass()方法以及class文件加载转换成字节码流的代码</strong>。那么<strong>编写自定义类加载器的意义</strong>何在呢？</p>
<p>简单来讲:<strong>隔离加载类</strong>，<strong>修改类加载方式</strong>，<strong>扩展加载源</strong>，<strong>防止源码泄露</strong></p>
<p>1.当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。</p>
<p>2.当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。</p>
<p>3.当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)，需要实现自定义ClassLoader的逻辑。</p>
<h4 id="引导类加载器（Bootstrap-ClassLoader）"><a href="#引导类加载器（Bootstrap-ClassLoader）" class="headerlink" title="引导类加载器（Bootstrap ClassLoader）"></a>引导类加载器（Bootstrap ClassLoader）</h4><p>启动类加载器<strong>主要加载的是JVM自身需要的类</strong>，这个类加载<strong>使用C++语言实现</strong>的，是<strong>虚拟机自身的一部分</strong>，它<strong>负责将 <JAVA_HOME>&#x2F;lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中</strong>，注意由于<strong>虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的</strong>(出于<strong>安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</strong>)。</p>
<h4 id="扩展类加载器（Extension-ClassLoader）"><a href="#扩展类加载器（Extension-ClassLoader）" class="headerlink" title="扩展类加载器（Extension ClassLoader）"></a>扩展类加载器（Extension ClassLoader）</h4><p>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由<strong>Java语言实现</strong>的，是<strong>Launcher的静态内部类</strong>，它<strong>负责加载<JAVA_HOME>&#x2F;lib&#x2F;ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库</strong>，开发者可以直接使用标准扩展类加载器。</p>
<h4 id="系统类加载器（System-ClassLoader）"><a href="#系统类加载器（System-ClassLoader）" class="headerlink" title="系统类加载器（System ClassLoader）"></a>系统类加载器（System ClassLoader）</h4><p>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它<strong>负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库</strong>，也就是我们经常用到的<strong>classpath路径</strong>，开发者可以直接使用系统类加载器，<strong>一般情况下该类加载器是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//系统类加载器获取</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line">        <span class="comment">//jdk.internal.loader.ClassLoaders$AppClassLoader@27c170f0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//系统类加载器获取其上层 扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoaderParent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(systemClassLoaderParent);</span><br><span class="line">        <span class="comment">//jdk.internal.loader.ClassLoaders$PlatformClassLoader@4f3f5b24</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//扩展类加载器获取其上层 引导类加载器 --获取不到</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoaderParentParent</span> <span class="operator">=</span> systemClassLoaderParent.getParent();</span><br><span class="line">        System.out.println(systemClassLoaderParentParent);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于自定义类加载器 默认使用系统类加载器进行加载</span></span><br><span class="line">        System.out.println(ClassLoadingTest3.class.getClassLoader());</span><br><span class="line">        <span class="comment">//jdk.internal.loader.ClassLoaders$AppClassLoader@27c170f0同系统类加载器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//String类的类加载器查看 引导类加载器加载 系统的核心类库都是使用引导类加载器进行加载的</span></span><br><span class="line">        System.out.println(String.class.getClassLoader());</span><br><span class="line">        <span class="comment">//null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920134602495.png" alt="image-20220920134602495"></p>
<p><strong>获取ClassLoader的方式</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920144548977.png" alt="image-20220920144548977"></p>
<h4 id="类加载器间的关系"><a href="#类加载器间的关系" class="headerlink" title="类加载器间的关系"></a>类加载器间的关系</h4><p>我们进一步了解类加载器间的关系(并非指继承关系)，主要可以分为以下4点</p>
<p><strong>启动类加载器</strong>，由C++实现，嵌套在JVM内部 加载Java核心类库 没有父类。</p>
<p>**拓展类加载器(ExtClassLoader)**，派生于ClassLoader 由Java语言实现，父类加载器为启动类加载器（null 获取不到）</p>
<p> (Java程序默认加载器）**系统类加载器(AppClassLoader)**，派生于ClassLoader 由Java语言实现，父类加载器为扩展类加载器ExtClassLoader </p>
<p><strong>自定义类加载器</strong>，父类加载器肯定为AppClassLoader。</p>
<h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p> 在Java的<strong>日常应用程序开发中</strong>，<strong>类的加载几乎是由引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）3种类加载器相互配合执行的</strong>，在必要时，我们还可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，<strong>Java虚拟机采用的是双亲委派模式即把请求交由父类处理</strong>，它<strong>一种任务委派模式–双亲委派模式</strong></p>
<p><strong>非继承关系</strong></p>
<p>双亲委派模式要求<strong>除了顶层的启动类加载器外</strong>，<strong>其余的类加载器都应当有自己的父类加载器</strong>，请注意双亲委派模式中的父子关系<strong>并非通常所说的类继承关系</strong>，而是<strong>采用组合关系来复用父类加载器的相关代码</strong>，类加载器间的关系如下：</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920134602495.png" alt="image-20220920134602495"></p>
<p><strong>双亲委派模式是在Java 1.2后引入的</strong>，<strong>其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成.</strong></p>
<h5 id="双亲委派模式优势"><a href="#双亲委派模式优势" class="headerlink" title="双亲委派模式优势"></a>双亲委派模式优势</h5><h6 id="避免重复加载"><a href="#避免重复加载" class="headerlink" title="避免重复加载"></a>避免重复加载</h6><p><strong>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</strong></p>
<h6 id="安全因素-沙箱安全机制"><a href="#安全因素-沙箱安全机制" class="headerlink" title="安全因素-沙箱安全机制"></a>安全因素-沙箱安全机制</h6><p><strong>防止核心API被随意篡改</strong>（对核心源码的保护）</p>
<p><strong>其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920154750258.png" alt="image-20220920154750258"></p>
<p><strong>可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920152230945.png" alt="image-20220920152230945"></p>
<p>java.lang.SecurityException: Prohibited package name: java.lang</p>
<p><strong>所以无论如何都无法加载成功的</strong></p>
<h5 id="从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现"><a href="#从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现" class="headerlink" title="从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现"></a>从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920151406561.png" alt="image-20220920151406561"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920140502286.png" alt="image-20220920140502286"></p>
<p><strong>从图可以看出顶层的类加载器是ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</strong></p>
<h5 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h5><p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。<br>    线程上下文类加载器（contextClassLoader）是从 JDK 1.2 开始引入的，我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源，如下图所示，以jdbc.jar加载为例</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920152641999.png" alt="image-20220920152641999"></p>
<p>从图可知<strong>rt.jar核心包是有Bootstrap类加载器加载的</strong>，<strong>其内包含SPI核心接口类，由于SPI中的类经常需要调用外部实现类的方法，而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载</strong>，因此只能<strong>委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用</strong>。显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”，<strong>它在执行过程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，当然这也使得Java类加载器变得更加灵活</strong>。为了进一步证实这种场景，不妨看看DriverManager类的源码，DriverManager是Java核心rt.jar包中的类，该类用来管理不同数据库的实现驱动即Driver，它们都实现了Java核心包中的java.sql.Driver接口，如mysql驱动包中的com.mysql.jdbc.Driver，这里主要看看如何加载外部实现类，在DriverManager初始化时会执行如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DriverManager是Java核心包rt.jar的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span> &#123;</span><br><span class="line">	<span class="comment">//省略不必要的代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();<span class="comment">//执行该方法</span></span><br><span class="line">        println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//loadInitialDrivers方法</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">     sun.misc.Providers()</span><br><span class="line">     AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="comment">//加载外部的Driver的实现类</span></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">              <span class="comment">//省略不必要的代码......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在DriverManager类初始化时执行了loadInitialDrivers()方法,在该方法中通过ServiceLoader.load(Driver.class);去加载外部实现的驱动类，ServiceLoader类会去读取mysql的jdbc.jar下META-INF文件的内容，如下所示<br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220920153320008.png" alt="image-20220920153320008"></p>
<p>很明显了确实通过线程上下文类加载器加载的，实际上<strong>核心包的SPI类对外部实现类的加载都是基于线程上下文类加载器执行的</strong>，通过这种方式实现了<strong>Java核心代码内部去调用外部实现类</strong>。我们知道<strong>线程上下文类加载器默认情况下就是AppClassLoader</strong>，</p>
<p>那<strong>为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类</strong>的呢？其实是可行的，但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点，那就是代码<strong>部署到不同服务时会出现问题</strong>，如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题，因为<strong>这些服务使用的线程上下文类加载器并非AppClassLoader，而是Java Web应用服自家的类加载器，类加载器不同</strong>。，所以我们应用该少用getSystemClassLoader()。总之不同的服务使用的可能默认ClassLoader是不同的，但<strong>使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader，从而避免不必要的问题</strong></p>
<h4 id="ClassLoader卸载Class"><a href="#ClassLoader卸载Class" class="headerlink" title="ClassLoader卸载Class"></a><strong>ClassLoader卸载Class</strong></h4><p>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p>
<ul>
<li>该类所有的实例都已经被GC。</li>
<li>加载该类的ClassLoader实例已经被GC。</li>
<li>该类的java.lang.Class对象没有在任何地方被引用。</li>
</ul>
<p><strong>GC的时机我们是不可控的，那么同样的我们对于Class的卸载也是不可控的</strong></p>
<h3 id="JVM中判断class对象相同的标准"><a href="#JVM中判断class对象相同的标准" class="headerlink" title="JVM中判断class对象相同的标准"></a>JVM中判断class对象相同的标准</h3><p><strong>1.类的完整类名必须一致 包括包名</strong></p>
<p><strong>2.加载这个类的ClassLoader（指类加载器的实例对象）必须相同</strong></p>
<p>换言之 在JVM中 即使两个类对象（class对象）来源于同一个class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不同。</p>
<h3 id="类加载器的引用"><a href="#类加载器的引用" class="headerlink" title="类加载器的引用"></a>类加载器的引用</h3><p>JVM必须知道一个类的类型是由启动类加载器加载还是由用户类加载器加载。</p>
<p><strong>若由用户类加载器加载</strong>：<strong>JVM会将这个类加载器的一个引用作为类信息的一部分保存在方法区（jdk8元空间）中</strong>；当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的类加载器是相同的。</p>
<h3 id="Java程序对类的使用方式"><a href="#Java程序对类的使用方式" class="headerlink" title="Java程序对类的使用方式"></a>Java程序对类的使用方式</h3><p>会不会<strong>导致类的初始化</strong> 决定是主动使用还是被动使用</p>
<h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p>1.创建类的实例</p>
<p>2.访问某个类或接口的静态变量，或者对该静态变量赋值</p>
<p>3.调用类的静态方法</p>
<p>4.反射（Class.forName(“全类名”)）</p>
<p>5.初始化一个类的子类</p>
<p>6.Java虚拟机启动时被表明为启动类的类</p>
<p>7.JDK7开始提供的动态语言支持：</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922102407895.png" alt="image-20220922102407895"></p>
<h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了主动使用的7种情况 其他使用Java类的方式都被看作是对类的<strong>被动使用</strong>，<strong>都不会导致类的初始化</strong>。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><strong>内存</strong> 是<strong>硬盘</strong>和<strong>CPU</strong>的<strong>中间仓库及桥梁</strong> <strong>承载着操作系统和应用程序的实时运行</strong>。</p>
<p><strong>JVM</strong>内存布局规定了Java在运行过程中<strong>内存申请，分配，管理的策略</strong>。<strong>保证JVM的高效稳定运行</strong></p>
<p><strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异。</strong></p>
<p><strong>根据《Java 虚拟机规范(Java SE 7 版)》规定</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922103004735.png" alt="image-20220922103004735"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922103042499.png" alt="image-20220922103042499"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922103933396.png" alt="image-20220922103933396"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922104555434.png" alt="image-20220922104555434">红色的为多个线程共享，灰色的为单个线程私有的，即</p>
<p><strong>线程间共享：堆，对外内存。</strong></p>
<p><strong>每个线程：独立包括程序计数器，栈，本地方法栈</strong><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922104700100.png" alt="image-20220922104700100"></p>
<h3 id="程序计数器（PC-Regisster）"><a href="#程序计数器（PC-Regisster）" class="headerlink" title="程序计数器（PC Regisster）"></a>程序计数器（PC Regisster）</h3><p><strong>Program Counter Register</strong>	程序计数寄存器</p>
<p><strong>作用：PC 寄存器 用来储存指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922114918122.png" alt="image-20220922114918122"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922112757011.png" alt="image-20220922112757011"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922114457556.png" alt="image-20220922114457556"></p>
<p><strong>内存空间小，线程私有</strong>。<strong>字节码解释器工作</strong>是就是<strong>通过改变这个计数器的值来选取下一条需要执行指令的字节码指令</strong>，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</strong></p>
<p><strong>如果线程正在执行一个 Java 方法</strong>，这个计数器记录的是<strong>正在执行的虚拟机字节码指令的地址</strong>；</p>
<p><strong>如果正在执行的是 Native 方法</strong>，这个计数器的值则为 **(Undefined)**。</p>
<p><strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域</strong>程序计数器的特点</p>
<p>　　1.线程隔离性，每个线程工作时都有属于自己的独立计数器。<br>　　2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址（参考上一小节的描述）。<br>　　3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C&#x2F;C++库，可以近似的认为native方法相当于C&#x2F;C++暴露给java的一个接口，java通过调用这个接口从而调用到C&#x2F;C++方法。由于该方法是通过C&#x2F;C++而不是java进行实现。那么自然无法产生相应的字节码，并且C&#x2F;C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922103004735.png" alt="image-20220922103004735"></p>
<h4 id="程序计算器常见问题"><a href="#程序计算器常见问题" class="headerlink" title="程序计算器常见问题"></a>程序计算器常见问题</h4><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922115103658.png" alt="image-20220922115103658"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922115138514.png" alt="image-20220922115138514"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922115320841.png" alt="image-20220922115320841"></p>
<h4 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片 "></a>CPU时间片 <img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922115459403.png" alt="image-20220922115459403"></h4><h4 id="CPU-并行-并发"><a href="#CPU-并行-并发" class="headerlink" title="CPU 并行 并发"></a><strong>CPU 并行 并发</strong></h4><p><strong>并发：CPU单个核心同时处理多个线程</strong>（各个线程争夺CPU时间片，在各个线程间来回高频的切换）</p>
<p><strong>并行：CPU多个核心处理多个线程</strong></p>
<h3 id="虚拟机栈（JVM-Stack）"><a href="#虚拟机栈（JVM-Stack）" class="headerlink" title="虚拟机栈（JVM Stack）"></a>虚拟机栈（JVM Stack）</h3><p><strong>线程私有，生命周期和线程一致。</strong>描述的是 Java 方法执行的内存模型：<strong>每个方法在执行时都会床创建一个栈帧(Stack Frame)<strong>用于</strong>存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。<strong>每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程</strong>。<strong>负责管理Java程序的运行</strong></p>
<p><strong>局部变量表</strong>：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p>
<p><strong>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。</strong><br><strong>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922121032602.png" alt="image-20220922121032602"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922121325647.png" alt="image-20220922121325647"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922121415970.png" alt="image-20220922121415970"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922120356973.png" alt="image-20220922120356973"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922120446022.png" alt="image-20220922120446022"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922120737732.png" alt="image-20220922120737732"></p>
<h4 id="栈可能会出现的异常"><a href="#栈可能会出现的异常" class="headerlink" title="栈可能会出现的异常"></a>栈可能会出现的异常</h4><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922121753369.png" alt="image-20220922121753369"></p>
<h4 id="设置栈固定的内存大小"><a href="#设置栈固定的内存大小" class="headerlink" title="设置栈固定的内存大小"></a>设置栈固定的内存大小</h4><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922121856779.png" alt="image-20220922121856779"></p>
<h4 id="栈的储存单位-栈帧"><a href="#栈的储存单位-栈帧" class="headerlink" title="栈的储存单位-栈帧"></a>栈的储存单位-栈帧</h4><p><strong>基本单位:栈帧</strong> <strong>线程上正在执行的每个方法对应一个栈帧</strong><br><strong>栈 遵循先进后出的原则 只有push压栈 pop弹出栈</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922122019231.png" alt="image-20220922122019231"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922122228725.png" alt="image-20220922122228725"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922122243126.png" alt="image-20220922122243126"></p>
<h4 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h4><p><strong>每一个栈帧</strong>都包括了<strong>局部变量表</strong>、<strong>操作数栈</strong>、动态连接、方法返回地址和一些额外的附加信息。 <strong>在编译Java程序源码的时候</strong>，<strong>栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算 出来</strong>，并且<strong>写入到方法表的Code属性之中</strong>[2]。换言之，一个栈帧需要分配多少内存，并不会受到程序 运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式<br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922153214796.png" alt="image-20220922153214796"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922133628454.png" alt="image-20220922133628454"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922140150860.png" alt="image-20220922140150860"></p>
<h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922140309136.png" alt="image-20220922140309136"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144053348.png" alt="image-20220922144053348"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922141344440.png" alt="image-20220922141344440"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922141157285.png" alt="image-20220922141157285"></p>
<h6 id="slot槽-重复利用"><a href="#slot槽-重复利用" class="headerlink" title="slot槽 重复利用"></a>slot槽 重复利用</h6><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144036851.png" alt="image-20220922144036851"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144108124.png" alt="image-20220922144108124"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144120973.png" alt="image-20220922144120973"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144135710.png" alt="image-20220922144135710"></p>
<h6 id="静态变量和局部变量的对比"><a href="#静态变量和局部变量的对比" class="headerlink" title="静态变量和局部变量的对比"></a>静态变量和局部变量的对比</h6><p><strong>局部变量必须显性初始化</strong> </p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144310733.png" alt="image-20220922144310733"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144332069.png" alt="image-20220922144332069"></p>
<h6 id="静态方法-amp-非静态方法的局部变量表"><a href="#静态方法-amp-非静态方法的局部变量表" class="headerlink" title="静态方法&amp;非静态方法的局部变量表"></a>静态方法&amp;非静态方法的局部变量表</h6><p><strong>静态方法的局部变量表中无this变量 因此静态方法中无法使用this.</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922145200405.png" alt="image-20220922145200405"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144804451.png" alt="image-20220922144804451"></p>
<p><strong>非静态方法中默认都存在this变量</strong><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922145236412.png" alt="image-20220922145236412"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922144828044.png" alt="image-20220922144828044"></p>
<h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO） 栈。同局部变量表一样，<strong>操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项 之中</strong>。</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922153608081.png" alt="image-20220922153608081"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922150755930.png" alt="image-20220922150755930"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922150447171.png" alt="image-20220922150447171"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922150457435.png" alt="image-20220922150457435"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922150557178.png" alt="image-20220922150557178"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922150921447.png" alt="image-20220922150921447"></p>
<p><strong>代码演示</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922151651694.png" alt="image-20220922151651694"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922151601001.png" alt="image-20220922151601001"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922151610177.png" alt="image-20220922151610177"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922151618655.png" alt="image-20220922151618655"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922151630355.png" alt="image-20220922151630355"></p>
<h5 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220922152641277.png" alt="image-20220922152641277"></p>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924115541013.png" alt="image-20220924115541013"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924115552912.png" alt="image-20220924115552912"></p>
<h5 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h5><h6 id="非虚方法"><a href="#非虚方法" class="headerlink" title="非虚方法"></a>非虚方法</h6><p><strong>早在编译期就确定了 在运行时是不可变的</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924130607798.png" alt="image-20220924130607798"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924130732990.png" alt="image-20220924130718490"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924130747487.png" alt="image-20220924130747487"></p>
<h6 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h6><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927090842602.png" alt="image-20220927090842602"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924130821628.png" alt="image-20220924130821628"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924130804702.png" alt="image-20220924130804702"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924130858208.png" alt="image-20220924130858208"></p>
<h6 id="普通调用指令"><a href="#普通调用指令" class="headerlink" title="普通调用指令"></a>普通调用指令</h6><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924131136904.png" alt="image-20220924131136904"></p>
<h6 id="动态调用指令"><a href="#动态调用指令" class="headerlink" title="动态调用指令"></a>动态调用指令</h6><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924131144565.png" alt="image-20220924131144565"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924131227943.png" alt="image-20220924131227943"><br><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924131239943.png" alt="image-20220924131239943"></p>
<h5 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h5><p><strong>方法返回</strong></p>
<p>　　　　当一个方法开始执行的时候，可能有<strong>正常退出</strong>和<strong>异常退出</strong>两种情况。</p>
<p>　　　　<strong>正常退出</strong>是指方法正常完成操作并退出，没有抛出任何异常，如果当前方法正常完成，则根据当前方法返回的字节码指令进行处理。该方法返回的字节码指令中有可能存在返回值，也可能不存在返回值。</p>
<p>　　　　<strong>异常退出</strong>是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。也就是说无论是Java虚拟机抛出的异常还是代码中使用throw产生的异常，只要在本方法的异常表中没有找到对应的异常处理器，就会导致方法退出。</p>
<p>　　　　无论方法采用何种方式退出，<strong>在方法退出后都需要返回到方法被调用的位置，程序才能继续执行</strong>，方法返回时可能需要在当前栈帧中保存一些信息，用来帮它恢复其上层方法的执行状态。<strong>方法退出过程实际上等同于把当前栈帧出栈</strong>，因此退出可以执行的操作有：<strong>恢复上层方法的局部变量表和操作数栈，如果有返回值，需要将返回值压入调用者的操作数栈中</strong>，同时<strong>调整PC计数器的值以指向方法调用指令后的下一条指令</strong>。</p>
<p>　　　　一般来说，<strong>方法正常退出时，调用者的PC计数器值可以作为返回地址</strong>，栈帧中可能保存此计数值，<strong>而方法异常退出时，返回地址是通过异常处理器表确定的</strong>，栈帧中一般不会保存此部分信息</p>
<h5 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h5><h4 id="方法的结束-栈的pop"><a href="#方法的结束-栈的pop" class="headerlink" title="方法的结束-栈的pop"></a>方法的结束-栈的pop</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 虚拟机栈的查看</span></span><br><span class="line"><span class="comment"> * 方法的结束分为两种 一种是正常的函数返回(return) 一种是抛出异常的结束 都会导致栈帧pop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ClassLoadingTest6</span> <span class="variable">classLoadingTest6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoadingTest6</span>();</span><br><span class="line">            System.out.println(classLoadingTest6.method1());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Eddie&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(10/0);</span></span><br><span class="line">        <span class="keyword">return</span> method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟机栈相关面试题"><a href="#虚拟机栈相关面试题" class="headerlink" title="虚拟机栈相关面试题"></a>虚拟机栈相关面试题</h4><p><strong>①：举例栈溢出的情况？（溢出异常：StackOverFlowError）</strong></p>
<p>​	通过-Xss设置栈的大小</p>
<p><strong>②：调整栈的大小，就能保证不出现栈溢出吗？</strong></p>
<p>​	无法保证；比如递归调用无归情况时；</p>
<p><strong>③：分配的栈内存越大越好吗？</strong></p>
<p>​	只是避免过早的出现溢出异常：StackOverFlowError </p>
<p>​	栈内存大了 会影响线程数的数量 会挤占别的内存空间</p>
<p><strong>④：垃圾回收会涉及到虚拟机栈吗？</strong></p>
<p>​	不会的；进栈出栈</p>
<p><strong>⑤：方法中定义的局部变量是否线程安全？</strong></p>
<p>​	具体问题具体分析</p>
<p>​	比如StringBuilder 线程不安全 </p>
<p>​	StringBuffer线程安全 </p>
<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p><strong>本地方法栈是用于管理本地方法的调用</strong></p>
<p><strong>当一个线程调用了一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机有同样的权限。</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924141814214.png" alt="image-20220924141814214"></p>
<h4 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h4><p>Native标识 本地方法</p>
<p>一个Native Method就是一个Java调用非Java代码的接口。</p>
<p><strong>为了和Java环境外交互</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924141918126.png" alt="image-20220924141918126"></p>
<p>例如线程在调用Start（）方法来启动线程时 实际是系统调用本地方法start0（）来启动线程</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220924142141419.png" alt="image-20220924142141419"></p>
<h3 id="堆（heep）"><a href="#堆（heep）" class="headerlink" title="堆（heep）"></a>堆（heep）</h3><h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927101930526.png" alt="image-20220927101930526"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927101843595.png" alt="image-20220927101843595"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927102014262.png" alt="image-20220927102014262"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927101916109.png" alt="image-20220927101916109"></p>
<h5 id="分区思想"><a href="#分区思想" class="headerlink" title="分区思想"></a>分区思想</h5><p>研究表明：不同的对象 生命周期不同 百分之70-百分之90的对象都是临时对象（朝生夕死）</p>
<p>新生代：有Eden区和两个幸存者区Survivor0以及Survivor1（from以及to）构成；to总为空。</p>
<p>老年代：存放在新生代中经历多次GC（阈值默认15）仍然存活的对象</p>
<p><strong>分区的唯一理由就是优化GC的性能</strong></p>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>新对象和没达到一定年龄的对象都在新生代</p>
<p>**Survivor0和Survivor1永远只有一个在被使用 两个不会同时使用 ** 	即有一个幸存者空间总是空的</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927101941987.png" alt="image-20220927101941987"></p>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>被长时间使用的对象，老年代的内存空间应该要比年轻代更大</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927101954168.png" alt="image-20220927101954168"></p>
<h5 id="元空间（非堆）"><a href="#元空间（非堆）" class="headerlink" title="元空间（非堆）"></a>元空间（非堆）</h5><p>（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927102003408.png" alt="image-20220927102003408"></p>
<h5 id="设置堆内存大小和-OOM"><a href="#设置堆内存大小和-OOM" class="headerlink" title="设置堆内存大小和 OOM"></a>设置堆内存大小和 OOM</h5><h5 id="手动设置"><a href="#手动设置" class="headerlink" title="手动设置"></a>手动设置</h5><p>开发中建议将初始堆内存 和 最大堆内存设置为一样的值</p>
<p>-Xms6000m -Xmx6000m</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927103311050.png" alt="image-20220927103311050"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927102743735.png" alt="image-20220927102743735"></p>
<h5 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 JVM 堆大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">initalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//返回 JVM 堆的最大内存</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;-Xms : &quot;</span>+initalMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-Xmx : &quot;</span>+maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + initalMemory * <span class="number">64</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;系统内存大小：&quot;</span> + maxMemory * <span class="number">4</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">    <span class="comment">//-Xms : 254M</span></span><br><span class="line">    <span class="comment">//-Xmx : 4064M</span></span><br><span class="line">    <span class="comment">//系统内存大小：15G</span></span><br><span class="line">    <span class="comment">//系统内存大小：15G</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查看-设置的参数"><a href="#查看-设置的参数" class="headerlink" title="查看 设置的参数"></a>查看 设置的参数</h5><p>两种方式</p>
<p>①:cmd–jps–jstat -gc 进程id</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927105415037.png" alt="image-20220927105415037"></p>
<p>②:-XX:+PrintGCDetails</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927105528630.png" alt="image-20220927105528630"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927105607060.png" alt="image-20220927105607060"></p>
<h5 id="查看-JVM-堆内存分配"><a href="#查看-JVM-堆内存分配" class="headerlink" title="查看 JVM 堆内存分配"></a>查看 JVM 堆内存分配</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927110813485.png" alt="image-20220927110813485"></p>
<h5 id="对象在堆中的生命周期"><a href="#对象在堆中的生命周期" class="headerlink" title="对象在堆中的生命周期"></a>对象在堆中的生命周期</h5><p>我们的很多对象都是朝生夕死的</p>
<p>一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理)</p>
<p>这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927111435033.png" alt="image-20220927111435033"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927113802658.png" alt="image-20220927113802658"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927114247641.png" alt="image-20220927114247641"></p>
<h5 id="对象的分配过程"><a href="#对象的分配过程" class="headerlink" title="对象的分配过程"></a>对象的分配过程</h5><p>其中 幸存者区的from区和to区复制（复制算法）之后进行交换 谁空谁为to</p>
<p>一GC一交换 谁空谁是to</p>
<p>关于GC：频繁在新生代中收集 很少在老年代中收集，几乎不在永久代&#x2F;元空间中收集</p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927114457272.png" alt="image-20220927114457272"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927134856686.png" alt="image-20220927134856686"></p>
<h5 id="对象的分配过程的特殊情况"><a href="#对象的分配过程的特殊情况" class="headerlink" title="对象的分配过程的特殊情况"></a>对象的分配过程的特殊情况</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927121647339.png" alt="image-20220927121647339"></p>
<h5 id="GC-垃圾回收简介"><a href="#GC-垃圾回收简介" class="headerlink" title="GC 垃圾回收简介"></a>GC 垃圾回收简介</h5><p><strong>我们的很多对象都是朝生夕死的</strong>	<strong>因此Minor GC会频繁的触发</strong></p>
<p> <strong>Minor GC是Eden区满时触发（Survivor区满不会触发Minor GC）</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927124003012.png" alt="image-20220927124003012"></p>
<p>Major GC的速度 比 Minor GC通常 要慢10倍以上 从而STW的时间更长 </p>
<p><strong>调优时要减少Major GC的触发次数 Full GC的触发次数</strong></p>
<h5 id="内存分配策略（对象Promotion策略）"><a href="#内存分配策略（对象Promotion策略）" class="headerlink" title="内存分配策略（对象Promotion策略）"></a>内存分配策略（对象Promotion策略）</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927141828861.png" alt="image-20220927141828861"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927141855732.png" alt="image-20220927141855732"></p>
<p><strong>大对象直接分配到老年代（新生代无法承载的大对象 直接分配到老年代）</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927142308928.png" alt="image-20220927142308928"></p>
<h5 id="堆空间的参数设置"><a href="#堆空间的参数设置" class="headerlink" title="堆空间的参数设置"></a>堆空间的参数设置</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927154321104.png" alt="image-20220927154321104"></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927153736307.png" alt="image-20220927153736307"></p>
<h5 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><p><strong>目前来讲jdk7以来 空间分配担保 默认为true</strong> </p>
<p><strong>即：检测到老年代的最大可用的连续空间大于新生代所有对象的总空间（最坏情况下新生代的所有对象都存活下来要晋升到老年代）</strong></p>
<p>​			<strong>检测到老年代的最大可用连续空间是否大于历次晋升到老年代的对象的平均大小（按照往次的晋升统计）</strong></p>
<p>​		<strong>都会进行Minor GC 否则进行Full GC</strong></p>
<p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927153800393.png" alt="image-20220927153800393"></p>
<h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927151535365.png" alt="image-20220927151535365"></p>
<h5 id="堆是分配对象存储的唯一选择吗"><a href="#堆是分配对象存储的唯一选择吗" class="headerlink" title="堆是分配对象存储的唯一选择吗"></a>堆是分配对象存储的唯一选择吗</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927155518020.png" alt="image-20220927155518020"></p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927164118327.png" alt="image-20220927164118327"></p>
<p>逃逸分析在JIT编译器使用</p>
<p>执行引擎是解释器和JIT编译器混合使用的</p>
<p><strong>Hotspot虚拟机没有栈上分配 因此是通过标量替换实现的；</strong> <strong>标量替换将聚合量（对象）打散成标量（基本数据类型以及对象的引用）</strong></p>
<p>换言之：在Hotspot虚拟机中 通过逃逸分析 发现了未发生逃逸的对象 可以进行标量替换 将其存储于栈帧中的局部变量表里。减轻堆空间的压力（GC的频率）</p>
<p>**逃逸分析(Escape Analysis)**是目前 Java 虚拟机中比较前沿的优化技术**。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法**。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p><strong>JDK7以来默认开启逃逸分析；</strong></p>
<p><strong>开发中  能使用局部变量的就尽量不在方法外定义；</strong></p>
<p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</strong></li>
<li><strong>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</strong></li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">   <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   <span class="keyword">return</span> sb;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将sb返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>上述代码如果想要 <code>StringBuffer sb</code>不逃出方法，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">   <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">   sb.append(s1);</span><br><span class="line">   sb.append(s2);</span><br><span class="line">   <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p>
<p><strong>参数设置：</strong></p>
<ul>
<li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li>
<li>如果使用较早版本，可以通过<code>-XX&quot;+DoEscapeAnalysis</code>显式开启</li>
</ul>
<p>开发中使用局部变量，就不要在方法外定义。</p>
<h5 id="使用逃逸分析，编译器可以对代码做优化："><a href="#使用逃逸分析，编译器可以对代码做优化：" class="headerlink" title="使用逃逸分析，编译器可以对代码做优化："></a><strong>使用逃逸分析，编译器可以对代码做优化：</strong></h5><p><strong>基于逃逸分析：****逃逸分析是以下三个操作的大前提</strong></p>
<p><strong>对未发生逃逸的对象：</strong></p>
<p><strong>栈上分配</strong> 即分配到栈帧中的局部变量表中（局部变量表中只存储基本数据类型以及对象的引用）；</p>
<p>因此要对未发生逃逸的对象进行<strong>标量替换</strong>将<strong>聚合量（对象）打散成标量（基本数据类型以及对象的引用）</strong></p>
<ul>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器（Java的Hotspot中的栈）–<strong>标量替换可以视为栈上分配的一种特例</strong>；</li>
</ul>
<p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p>
<p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p>
<p><strong>代码优化之同步省略（锁消除）</strong></p>
<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li>
<li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">synchronized</span>(keeper) &#123;</span><br><span class="line">    System.out.println(keeper);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>如上代码，代码中对 keeper 这个对象进行加锁，但是 keeper 对象的生命周期只在 <code>keep()</code>方法中，并不会被其他线程所访问到，所以在 JIT编译阶段就会被优化掉。优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keep</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">keeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  System.out.println(keeper);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>代码优化之标量替换</strong></p>
<p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p>
<p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p>
<p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器（Java的Hotspot中的栈）上分配空间。这个过程就是<strong>标量替换</strong>。</p>
<p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   alloc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>（<span class="number">1</span>,<span class="number">2</span>）;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+point.x+<span class="string">&quot;; point.y=&quot;</span>+point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>以上代码中，point 对象并没有逃逸出 <code>alloc()</code> 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">   System.out.println(<span class="string">&quot;point.x=&quot;</span>+x+<span class="string">&quot;; point.y=&quot;</span>+y);</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p><strong>代码优化之栈上分配</strong></p>
<p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
<h5 id="逃逸分析总结："><a href="#逃逸分析总结：" class="headerlink" title="逃逸分析总结："></a><strong>逃逸分析总结：</strong></h5><p><img src="C:\Users\ZJH20\AppData\Roaming\Typora\typora-user-images\image-20220927164103083.png" alt="image-20220927164103083"></p>
<p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p>
<p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p>
<p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p>
<p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/22/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EJVM%EF%BC%88%E5%9F%BA%E4%BA%8Ehotspot%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">关于JVM（基于hotspot）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">JVM整体结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B-%E5%9F%BA%E4%BA%8E%E6%A0%88%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">JVM的架构模型 基于栈式架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.</span> <span class="nav-text">JVM生命周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.</span> <span class="nav-text">JVM内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">类加载器和类的加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">类的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">2.1.2.2.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Bootstrap-ClassLoader%EF%BC%89"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">引导类加载器（Bootstrap ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88Extension-ClassLoader%EF%BC%89"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">扩展类加载器（Extension ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88System-ClassLoader%EF%BC%89"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">系统类加载器（System ClassLoader）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">类加载器间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">双亲委派模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E4%BC%98%E5%8A%BF"><span class="nav-number">2.1.3.5.1.</span> <span class="nav-text">双亲委派模式优势</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.1.3.5.1.1.</span> <span class="nav-text">避免重复加载</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%9B%A0%E7%B4%A0-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">2.1.3.5.1.2.</span> <span class="nav-text">安全因素-沙箱安全机制</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E4%BA%86%E8%A7%A3%E5%87%A0%E4%B8%AAJava%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8A%E5%85%B6%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.3.5.2.</span> <span class="nav-text">从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.1.3.5.3.</span> <span class="nav-text">线程上下文类加载器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassLoader%E5%8D%B8%E8%BD%BDClass"><span class="nav-number">2.1.3.6.</span> <span class="nav-text">ClassLoader卸载Class</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E4%B8%AD%E5%88%A4%E6%96%ADclass%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%87%E5%87%86"><span class="nav-number">2.1.4.</span> <span class="nav-text">JVM中判断class对象相同的标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">2.1.5.</span> <span class="nav-text">类加载器的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%A8%8B%E5%BA%8F%E5%AF%B9%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.6.</span> <span class="nav-text">Java程序对类的使用方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">主动使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">被动使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC-Regisster%EF%BC%89"><span class="nav-number">2.2.1.</span> <span class="nav-text">程序计数器（PC Regisster）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97%E5%99%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">程序计算器常见问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E6%97%B6%E9%97%B4%E7%89%87"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">CPU时间片 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E5%B9%B6%E8%A1%8C-%E5%B9%B6%E5%8F%91"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">CPU 并行 并发</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88JVM-Stack%EF%BC%89"><span class="nav-number">2.2.2.</span> <span class="nav-text">虚拟机栈（JVM Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">栈可能会出现的异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%A0%88%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">设置栈固定的内存大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%82%A8%E5%AD%98%E5%8D%95%E4%BD%8D-%E6%A0%88%E5%B8%A7"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">栈的储存单位-栈帧</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E5%B8%A7%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">栈帧的内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">2.2.2.4.1.</span> <span class="nav-text">局部变量表</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#slot%E6%A7%BD-%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8"><span class="nav-number">2.2.2.4.1.1.</span> <span class="nav-text">slot槽 重复利用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.2.2.4.1.2.</span> <span class="nav-text">静态变量和局部变量的对比</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-amp-%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">2.2.2.4.1.3.</span> <span class="nav-text">静态方法&amp;非静态方法的局部变量表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88"><span class="nav-number">2.2.2.4.2.</span> <span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E9%A1%B6%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-number">2.2.2.4.3.</span> <span class="nav-text">栈顶缓存技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">2.2.2.4.4.</span> <span class="nav-text">动态链接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.2.4.5.</span> <span class="nav-text">方法的调用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%9E%E8%99%9A%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.4.5.1.</span> <span class="nav-text">非虚方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.4.5.2.</span> <span class="nav-text">虚方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.2.4.5.3.</span> <span class="nav-text">普通调用指令</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.2.4.5.4.</span> <span class="nav-text">动态调用指令</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.2.4.6.</span> <span class="nav-text">方法返回地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-number">2.2.2.4.7.</span> <span class="nav-text">附加信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E7%BB%93%E6%9D%9F-%E6%A0%88%E7%9A%84pop"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">方法的结束-栈的pop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">虚拟机栈相关面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">本地方法栈（Native Method Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">本地方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%EF%BC%88heep%EF%BC%89"><span class="nav-number">2.2.4.</span> <span class="nav-text">堆（heep）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-number">2.2.4.0.1.</span> <span class="nav-text">分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E6%80%9D%E6%83%B3"><span class="nav-number">2.2.4.0.2.</span> <span class="nav-text">分区思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="nav-number">2.2.4.0.3.</span> <span class="nav-text">新生代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">2.2.4.0.4.</span> <span class="nav-text">老年代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88%E9%9D%9E%E5%A0%86%EF%BC%89"><span class="nav-number">2.2.4.0.5.</span> <span class="nav-text">元空间（非堆）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%92%8C-OOM"><span class="nav-number">2.2.4.0.6.</span> <span class="nav-text">设置堆内存大小和 OOM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.4.0.7.</span> <span class="nav-text">手动设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="nav-number">2.2.4.0.8.</span> <span class="nav-text">默认情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.4.0.9.</span> <span class="nav-text">查看 设置的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-JVM-%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">2.2.4.0.10.</span> <span class="nav-text">查看 JVM 堆内存分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.2.4.0.11.</span> <span class="nav-text">对象在堆中的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.4.0.12.</span> <span class="nav-text">对象的分配过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="nav-number">2.2.4.0.13.</span> <span class="nav-text">对象的分配过程的特殊情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.4.0.14.</span> <span class="nav-text">GC 垃圾回收简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%EF%BC%88%E5%AF%B9%E8%B1%A1Promotion%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">2.2.4.0.15.</span> <span class="nav-text">内存分配策略（对象Promotion策略）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.4.0.16.</span> <span class="nav-text">堆空间的参数设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">2.2.4.0.17.</span> <span class="nav-text">空间分配担保</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLAB"><span class="nav-number">2.2.4.0.18.</span> <span class="nav-text">TLAB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97"><span class="nav-number">2.2.4.0.19.</span> <span class="nav-text">堆是分配对象存储的唯一选择吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-number">2.2.4.0.20.</span> <span class="nav-text">逃逸分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%81%9A%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="nav-number">2.2.4.0.21.</span> <span class="nav-text">使用逃逸分析，编译器可以对代码做优化：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">2.2.4.0.22.</span> <span class="nav-text">逃逸分析总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="nav-number">2.2.5.</span> <span class="nav-text">方法区（Method Area）</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">EddieZhang</p>
  <div class="site-description" itemprop="description">当你开始认真的时候，全世界都会给你让路！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EddieZhang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  















  

  

</body>
</html>
